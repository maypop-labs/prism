#' @title Extract switching gene list of interesting
#'
#' @description This function extract a list of significant switching genes
#'
#' @param sce switching genes
#' @param allgenes if use all genes
#' @param pathway_name a list of pathway name(s) to plot
#' @param genelists a gene list to plot
#' @param genetype specific gene type to plot c("EMT", "reprogramming", "stem", "surface", "TF")
#' @param zero_pct zero-expression percentage cut off for significant genes
#' @param r2cutoff pseudo R^2 cutoff
#' @param direction switching direction, up or down
#' @param topnum number of top genes ordered by pseudo R^2 value
#' @return
#'
#' @import plyr
#' @export
#'
filter_switchgenes <- function(sce, allgenes = FALSE, pathway_name = NULL, genelists = GeneSwitches:::gs_genelists,
                               genetype = c("Surface proteins", "TFs"), zero_pct = 0.9,
                               r2cutoff = 0.03, direction = c("up", "down"), topnum = 100000) {
  if (allgenes == TRUE) {
    toplotgl <- rowData(sce)
    toplotgl$feature_type <- "All genes"
  } else if(!is.null(pathway_name)) {
    gl <- c()
    for (pn in pathway_name) {
      pgl <- data.frame(msigdb_h_c2_c5[pn], pn, stringsAsFactors = FALSE)
      colnames(pgl) <- c("feature_name", "feature_type")
      gl <- rbind(gl, pgl)
    }
    multi <- gl$feature_name[duplicated(gl$feature_name)]
    if (length(multi) > 0) {
      gl <- ddply(gl,.(feature_name),paste)[,c(1,3)]
      rownames(gl) <- gl$feature_name
      colnames(gl)[2] <- "types"
      gl$feature_type <- gl$types
      gl[multi,]$feature_type <- "Multiple"
      genestoplot <- intersect(rownames(sce), gl$feature_name)
      toplotgl <- rowData(sce)[genestoplot, ]
      toplotgl$feature_type <- gl[genestoplot, ]$feature_type
      toplotgl$types <- gl[genestoplot, ]$types
    } else {
      rownames(gl) <- gl$feature_name
      genestoplot <- intersect(rownames(sce), gl$feature_name)
      toplotgl <- rowData(sce)[genestoplot, ]
      toplotgl$feature_type <- gl[genestoplot, ]$feature_type
    }
  } else {
    genelists_sub <- genelists[genelists$genetypes %in% genetype, ]
    genelists_sub <- genelists_sub[!duplicated(genelists_sub$genenames), ]
    rownames(genelists_sub) <- genelists_sub$genenames
    genestoplot <- intersect(rownames(sce), genelists_sub$genenames)
    toplotgl <- rowData(sce)[genestoplot, ]
    toplotgl$feature_type <- genelists_sub[genestoplot, ]$genetypes
  }

  toplotgl_sub <- toplotgl[toplotgl$zerop_gene < zero_pct & toplotgl$prd_quality == 1 & toplotgl$pseudoR2s > r2cutoff &
                           toplotgl$direction %in% direction, ]
  if (nrow(toplotgl_sub) > topnum) {
    toplotgl_sub <- toplotgl_sub[order(toplotgl_sub$pseudoR2s, decreasing = TRUE),]
    toplotgl_sub <- toplotgl_sub[1:topnum,]
  }
  return(toplotgl_sub)
}

#' @title Plot switching genes
#'
#' @description This function plots switching genes on the pseudo-timeline
#'
#' @param tml switching genes
#' @param timedata pseudotime for cells
#' @param iffulltml if plot the full timeline
#' @param txtsize text size for gene names
#' @param color_by the cell attribute (e.g. the column of tml) to map to each cell's color
#' @return
#'
#' @import ggplot2
#' @importFrom ggrepel geom_text_repel
#' @export
#'
plot_timeline_ggplot <- function(tml, timedata, iffulltml = TRUE, txtsize = 3.5, color_by = "feature_type") {
  tml <- as.data.frame(tml)
  tml <- tml[order(tml$switch_at_time), ]
  tml$direction_num <- -1
  if ("up" %in% tml$direction) {
    tml[tml$direction == "up", ]$direction_num <- 1
  }
  tml$color_by <- as.factor(tml[,color_by])
  tml$feature_name <- rownames(tml)
  head(tml)

  if (iffulltml) {
    pseudotime_step <- (max(timedata) - min(timedata))/4
    pseudotime_range <- seq(min(timedata), max(timedata), by = pseudotime_step)
    pseudotime_df <- data.frame(pseudotime_range, pseudotime_format = round(pseudotime_range, 1))
  } else {
    pseudotime_step <- (max(tml$switch_at_time) - min(tml$switch_at_time))/4
    pseudotime_range <- seq(min(tml$switch_at_time), max(tml$switch_at_time), by = pseudotime_step)
    pseudotime_df <- data.frame(pseudotime_range, pseudotime_format = round(pseudotime_range, 1))
  }

  tml_plot <- ggplot(tml, aes(x = switch_at_time, y = pseudoR2s * direction_num, col = color_by, label = feature_name)) +
    geom_point(size = txtsize/3) + xlab("Pseudo-timeline") + ylab("Quality of fitting (R^2)")
  tml_plot <- tml_plot + theme_classic()
  # Plot horizontal black line for timeline
  tml_plot <- tml_plot + geom_hline(yintercept = 0, color = "black", size = 0.6)
  tml_plot <- tml_plot + geom_label(data = pseudotime_df, aes(x = pseudotime_range, y = 0, label = pseudotime_format), size = (txtsize-0.5),
                                    color = "black")

  tml_plot <- tml_plot + geom_text_repel(aes(x = switch_at_time, y = pseudoR2s * direction_num, label = feature_name),
                                         size = txtsize, fontface = "bold", show.legend = FALSE)

  tml_plot <- tml_plot + theme(legend.position = "bottom", legend.title = element_blank(), legend.key.size = unit(10, "pt"),
                               text = element_text(size = 12, family = "Helvetica"))

  return(tml_plot)
}

#' @title Binarize gene expression
#'
#' @description This function generates on/off binarized data for gene expression
#'
#' @param sce SingleCellExperiment
#' @param fix_cutoff Logical. if use fixed global cutoff for binarization, default FALSE
#' @param binarize_cutoff fixed global cutoff for binarization, default 0.2
#' @param ncores number of cores
#' @return
#'
#' @import parallel
#' @importFrom mixtools normalmixEM
#' @export
#'
binarize_exp <- function(sce, fix_cutoff = FALSE, binarize_cutoff = 0.2, ncores = 3) {
  # calculate zero percentage
  zerop_g <- c()
  expdata <- assays(sce)$expdata
  for (i in 1:nrow(expdata)) {
    zp <- length(which(expdata[i, ] == 0))/ncol(expdata)
    zerop_g <- c(zerop_g, zp)
  }

  if (fix_cutoff == TRUE) {
    expdata <- assays(sce)$expdata
    is.na(expdata) <- assays(sce)$expdata == 0
    exp_reduced_binary <- as.matrix((expdata > binarize_cutoff) + 0)
    exp_reduced_binary[is.na(exp_reduced_binary)] = 0
    assays(sce)$binary <- exp_reduced_binary
    oupBinary <- data.frame(geneID = rownames(sce),
                            zerop_gene = zerop_g,
                            passBinary = TRUE)
    rowData(sce) <- oupBinary
  } else {
    expdata <- assays(sce)$expdata
    # Add gaussian noise to gene expression matrix
    # Here we use a sd of 0.1
    LogCountsadd = expdata + matrix(rnorm(nrow(expdata)*ncol(expdata),
                                          mean = 0, sd = 0.1),
                                    nrow(expdata), ncol(expdata))
    # Start fitting mixture models for each gene
    oupBinary = do.call(
      rbind, mclapply(rownames(LogCountsadd), function(iGene){
        set.seed(42)   # Set seed for consistency
        tmpMix = normalmixEM(LogCountsadd[iGene, ], k = 2)
        if (tmpMix$mu[1] < tmpMix$mu[2]) {
          tmpOup = data.frame(geneID = iGene,
                              mu1 = tmpMix$mu[1],
                              mu2 = tmpMix$mu[2],
                              sigma1 = tmpMix$sigma[1],
                              sigma2 = tmpMix$sigma[2],
                              lambda1 = tmpMix$lambda[1],
                              lambda2 = tmpMix$lambda[2],
                              loglik = tmpMix$loglik)
        } else {
          tmpOup = data.frame(geneID = iGene,
                              mu1 = tmpMix$mu[2],
                              mu2 = tmpMix$mu[1],
                              sigma1 = tmpMix$sigma[2],
                              sigma2 = tmpMix$sigma[1],
                              lambda1 = tmpMix$lambda[2],
                              lambda2 = tmpMix$lambda[1],
                              loglik = tmpMix$loglik)
        }
        return(tmpOup)
      }, mc.cores = ncores))

    # Check if non-bimodal genes
    oupBinary$passBinary = TRUE
    oupBinary[oupBinary$lambda1 < 0.1, ]$passBinary = FALSE
    oupBinary[oupBinary$lambda2 < 0.1, ]$passBinary = FALSE
    oupBinary[(oupBinary$mu2 - oupBinary$mu1) < (oupBinary$sigma1 + oupBinary$sigma2), ]$passBinary = FALSE
    # table(oupBinary$passBinary)

    # Solve for intersection for remaining genes
    oupBinary$root = -1
    for(iGene in oupBinary[oupBinary$passBinary == TRUE, ]$geneID){
      tmpMix = oupBinary[oupBinary$geneID == iGene, ]
      tmpInt = uniroot(function(x, l1, l2, mu1, mu2, sd1, sd2) {
        dnorm(x, m = mu1, sd = sd1) * l1 -
          dnorm(x, m = mu2, sd = sd2) * l2},
        interval = c(tmpMix$mu1,tmpMix$mu2),
        l1 = tmpMix$lambda1, mu1 = tmpMix$mu1, sd1 = tmpMix$sigma1,
        l2 = tmpMix$lambda2, mu2 = tmpMix$mu2, sd2 = tmpMix$sigma2)
      oupBinary[oupBinary$geneID == iGene, ]$root = tmpInt$root
    }
    # Binarize expression
    binLogCounts = expdata[oupBinary$geneID,]
    binLogCounts = t(scale(t(binLogCounts), scale = FALSE,
                           center = oupBinary$root))
    binLogCounts[binLogCounts >= 0] = 1
    binLogCounts[binLogCounts < 0] = 0
    assays(sce)$binary <- binLogCounts

    oupBinary$zerop_gene <- zerop_g
    rowData(sce) <- oupBinary
  }
  return(sce)
}

#' @title Random downsampling of zero expression
#'
#' @description This function does randomly downsampling of cells with zero expression for one gene
#'
#' @param glmdata binary data of one gene
#' @param ratio_ds downsampling zeros to this proportion
#' @return
#'
downsample_zeros <- function(glmdata, ratio_ds = 0.7) {
  p = as.numeric(ratio_ds)
  set.seed(42)   # Set seed for consistency
  downsample <- sample(which(glmdata$expvalue == 0), length(which(glmdata$expvalue == 0)) - round(sum(glmdata$expvalue != 0) * p/(1 - p)))
  if (length(downsample) > 0) {
    subdata <- glmdata[-downsample, ]
  } else {subdata <- glmdata}
  return(subdata)
}

#' @title Fit fast logistic regression and find switching timepoint
#'
#' @description This function fits fast logistic regression and find switching timepoint for each gene
#'
#' @param sce SingleCellExperiment
#' @param downsample Logical. if do random downsampling of zeros
#' @param ds_cutoff only do downsampling if zero percentage is over this cutoff
#' @param zero_ratio downsampling zeros to this proportion
#' @param sig_FDR FDR cut off for significant genes
#' @return
#'
#' @import fastglm
#' @export
#'
find_switch_logistic_fastglm <- function(sce, downsample = FALSE, ds_cutoff = 0.7, zero_ratio = 0.7,
                                         sig_FDR = 0.05, show_warnings = TRUE) {
  binarydata <- assays(sce)$binary
  expdata <- assays(sce)$expdata
  binarydata <- binarydata[which(rowData(sce)$passBinary == TRUE), ]
  expdata <- expdata[which(rowData(sce)$passBinary == TRUE), ]
  genes <- rowData(sce)[which(rowData(sce)$passBinary == TRUE), ]
  timedata <- sce$Pseudotime
  pvalues <- binarydata[, 1]
  pseudoR2s <- binarydata[, 1]
  estimates <- binarydata[, 1]
  switch_at_time <- binarydata[, 1]
  prd_quality <- binarydata[, 1]
  CI <- binarydata[, 1]

  for (i in 1:nrow(binarydata)) {
    glmdata <- cbind(State = as.numeric(binarydata[i, ]), expvalue = as.numeric(expdata[i, ]),
                     timedata = sce$Pseudotime)
    glmdata <- as.data.frame(glmdata)

    if (downsample == TRUE & round(genes$zerop_gene[i],3) > ds_cutoff) {
      glmdata <- downsample_zeros(glmdata, ratio_ds = zero_ratio)
    }

    if (show_warnings == TRUE) {
      glm_results <- fastglm(x = model.matrix(State ~ timedata, data = glmdata),
                             y = glmdata$State, family = binomial(link = "logit"))
    } else {
      glm_results <-suppressWarnings(fastglm(x = model.matrix(State ~ timedata, data = glmdata),
                                             y = glmdata$State, family = binomial(link = "logit")))
    }
    pvalues[i] <- coef(summary(glm_results))[, 4][2]
    ll.null <- glm_results$null.deviance/-2
    ll.proposed <- glm_results$deviance/-2
    # McFadden's Pseudo R^2 = [ LL(Null) - LL(Proposed) ] / LL(Null)
    pseudoR2s[i] <- (ll.null - ll.proposed)/ll.null
    estimates[i] <- coef(summary(glm_results))[, 1][2]
    # p=0.5
    switch_at_time[i] <- (log(0.5/(1 - 0.5)) - coef(glm_results)[1])/coef(glm_results)[2]
    if (switch_at_time[i] >= max(glmdata$timedata)) {
      switch_at_time[i] = max(glmdata$timedata)
      prd_quality[i] = 0
    } else {
      prd_quality[i] = 1
    }
    if (switch_at_time[i] <= min(glmdata$timedata)) {
      switch_at_time[i] = min(glmdata$timedata)
      prd_quality[i] = 0
    }
    se <- summary(glm_results)$coefficients[, 2]
    CI[i] <- sqrt((se[1]*1.96/coef(glm_results)[1])^2 + (se[2]*1.96/coef(glm_results)[2])^2)*
      abs(coef(glm_results)[1]/coef(glm_results)[2])
    remove(glm_results)
  }

  result_switch <- cbind(switch_at_time, CI, pvalues, pseudoR2s, estimates, prd_quality)
  rownames(result_switch) <- rownames(binarydata)
  result_switch <- as.data.frame(result_switch)
  result_switch$direction <- "up"
  result_switch[result_switch$estimates < 0, ]$direction <- "down"
  result_switch$FDR <- p.adjust(result_switch$pvalues, method = "BH")
  steptime <- (max(timedata) - min(timedata))/100
  result_switch$switch_at_timeidx <- round((result_switch$switch_at_time - min(timedata))/steptime)

  # process_resultswitch --------------------------------------------------------------------------
  # check significance FDR < sig_FDR
  if (max(result_switch$FDR) > sig_FDR) {
    result_switch[result_switch$FDR > sig_FDR, ]$prd_quality <- 0
  }

  geneinfo <- merge(rowData(sce), result_switch, by=0, all=TRUE)[,-1] #[,1:11]
  rownames(geneinfo) <- geneinfo$geneID
  # all(rownames(geneinfo) == rownames(sce))
  geneinfo <- geneinfo[rownames(sce), ]
  rowData(sce) <- geneinfo
  return(sce)
}